////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2016-2019 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  commonutilswin32.cpp
/// @brief General OS specific utility class implementation for Win32
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if defined (_WIN32)    // This file for Win32 build only

#include "commonutils.h"
#include "camera3common.h"
#include "nativetestlog.h"

#include <malloc.h>

namespace tests
{
/// @brief This structure is passed to the OS thread create function. This gets passed back to the thread by the OS when it
///        calls the thread main function entry point registered during thread create.
struct OSThreadParams
{
    OSThreadFunc    threadEntryFunction;    ///< Function to execute in new thread
    VOID*           pThreadData;            ///< Data passed to threadEntryFunction()
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// OSThreadLauncher
///
/// @brief  Main thread function called by the OS for all created threads
///
/// @param  pPrivateThreadData  Private data passed back to the thread. This data was given in the thread create call.
///
/// @return 0, indicating thread terminated
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static DWORD WINAPI OSThreadLauncher(
    LPVOID pPrivateThreadData)
{
    OSThreadParams* pParams = static_cast<OSThreadParams*>(pPrivateThreadData);
    OSThreadFunc    threadEntryFunction = pParams->threadEntryFunction;
    VOID*           pThreadData = pParams->pThreadData;

    // Once this function returns it means we need to terminate the thread
    threadEntryFunction(pThreadData);

    OsUtils::FreeAligned(pParams);

    return 0;   // 0 indicates the thread is terminated
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::Stat
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult OsUtils::Stat(
    const CHAR* pPath,
    StatType*   pBuffer)
{
    CDKResult result = CDKResultSuccess;
    if (0 != _stat64(pPath, pBuffer))
    {
        result = CDKResultEFailed;
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::FOpen
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FILE* OsUtils::FOpen(
    const CHAR* pFilename,
    const CHAR* pMode)
{
    FILE* pFile;
    if (0 != fopen_s(&pFile, pFilename, pMode))
    {
        pFile = NULL;
    }
    return pFile;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::FClose
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult OsUtils::FClose(
    FILE* pFile)
{
    CDKResult result = CDKResultSuccess;
    if (0 != fclose(pFile))
    {
        result = CDKResultEFailed;
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::FSeek
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult OsUtils::FSeek(
    FILE*   pFile,
    INT64   offset,
    INT     origin)
{
    CDKResult result = CDKResultSuccess;
    if (0 != _fseeki64(pFile, offset, origin))
    {
        result = CDKResultEFailed;
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::FTell
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT64 OsUtils::FTell(
    FILE* pFile)
{
    return _ftelli64(pFile);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::FPrintF
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT OsUtils::FPrintF(
    FILE*       pFile,
    const CHAR* pFormat,
    ...)
{
    INT     result;
    va_list argptr;

    va_start(argptr, pFormat);
    result = vfprintf_s(pFile, pFormat, argptr);
    va_end(argptr);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::FRead
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SIZE_T OsUtils::FRead(
    VOID*   pDst,
    SIZE_T  dstSize,
    SIZE_T  size,
    SIZE_T  count,
    FILE*   pFile)
{
    return fread_s(pDst, dstSize, size, count, pFile);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::FWrite
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SIZE_T OsUtils::FWrite(
    const VOID* pSrc,
    SIZE_T      size,
    SIZE_T      count,
    FILE*       pFile)
{
    return fwrite(pSrc, size, count, pFile);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::FFlush
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult OsUtils::FFlush(
    FILE* pFile)
{
    CDKResult result = CDKResultSuccess;
    if (0 != fflush(pFile))
    {
        result = CDKResultEFailed;
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::GetFileName
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const CHAR* OsUtils::GetFileName(
    const CHAR* pFilePath)
{
    const CHAR* pFileName = StrRChr(pFilePath, '\\');
    if (NULL != pFileName)
    {
        // StrRChr will return a pointer to the \, advance one to the filename
        pFileName += 1;
    }
    else
    {
        pFileName = pFilePath;
    }
    return pFileName;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::GetFileNameToken
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL OsUtils::GetFileNameToken(
    CHAR*  pFilePath,
    UINT32 tokenInputNum,
    CHAR*  pOutToken,
    SIZE_T maxTokenLen)
{
    UINT   tokenCount = 0;
    CHAR*  pToken = NULL;
    UINT16 result = FALSE;
    CHAR*  pContext = NULL;
    CHAR   outTokenString[FILENAME_MAX];

    OsUtils::StrLCpy(outTokenString, pFilePath, strlen(pFilePath));
    pToken = OsUtils::StrTokReentrant(outTokenString, ".", &pContext);

    // The binary name is of format com.<vendor>.<category>.<algorithm>.<extension>
    while (NULL != pToken)
    {
        tokenCount++;
        if (tokenInputNum == tokenCount)
        {
            OsUtils::StrLCpy(pOutToken, pToken, maxTokenLen);
            result = TRUE;
            break;
        }
        pToken = OsUtils::StrTokReentrant(NULL, ".", &pContext);
    }
    return result;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::GetFilesFromPath
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT16 OsUtils::GetFilesFromPath(
    const CHAR* pFileSearchPath,
    SIZE_T      maxFileNameLength,
    CHAR*       pFileNames,
    const CHAR* pVendorName,
    const CHAR* pCategoryName,
    const CHAR* pModuleName,
    const CHAR* pExtension)
{
    UINT16          fileCount = 0;
    WIN32_FIND_DATA searchData = { 0 };
    HANDLE          handle = NULL;
    CHAR            directoryPath[FILENAME_MAX];

    OsUtils::SNPrintF(directoryPath,
        FILENAME_MAX,
        "%s%scom.%s.%s.%s.%s",
        pFileSearchPath,
        PathSeparator,
        pVendorName,
        pCategoryName,
        pModuleName,
        pExtension);

    handle = FindFirstFile(reinterpret_cast<LPCSTR>(directoryPath), &searchData);

    while (handle != INVALID_HANDLE_VALUE)
    {
        OsUtils::SNPrintF(pFileNames + (fileCount * maxFileNameLength),
            maxFileNameLength,
            "%s%s%s",
            pFileSearchPath,
            PathSeparator,
            searchData.cFileName);
        fileCount++;

        if (FALSE == FindNextFile(handle, &searchData))
        {
            break;
        }
    }

    // Close the handle after use or memory/resource leak
    FindClose(handle);
    return fileCount;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::GetFileSize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT64 OsUtils::GetFileSize(
    const CHAR* pFilename)
{
    StatType   stats;
    UINT64     fileSize = 0;
    CDKResult result = Stat(pFilename, &stats);

    if (CDKResultSuccess == result)
    {
        fileSize = static_cast<UINT64>(stats.st_size);
    }

    return fileSize;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Memory functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// OsUtils::MallocAligned
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID* OsUtils::MallocAligned(
    SIZE_T size,
    SIZE_T alignment)
{
    VOID* pMem = NULL;
    bool isPowerOfTwo = ((alignment == 0) ? FALSE : (((alignment & (alignment - 1)) == 0) ? TRUE : FALSE));

    if (TRUE == isPowerOfTwo)
    {
        pMem = _aligned_malloc(size, alignment);
    }

    return pMem;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// OsUtils::FreeAligned
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID OsUtils::FreeAligned(
    VOID* pMem)
{
    _aligned_free(pMem);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// OsUtils::PageSize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT OsUtils::PageSize()
{
    SYSTEM_INFO si;
    GetSystemInfo(&si);

    return si.dwPageSize;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Thread functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::ThreadCreate
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult OsUtils::ThreadCreate(
    OSThreadFunc    threadEntryFunction,
    VOID*           pThreadData,
    OSThreadHandle* phThread)
{
    HANDLE          hNewThread = NULL;
    OSThreadParams* pParams = static_cast<OSThreadParams*>(MallocAligned(sizeof(OSThreadParams), sizeof(VOID*)));
    CDKResult       result = CDKResultSuccess;

    if (NULL != pParams)
    {
        pParams->threadEntryFunction = threadEntryFunction;
        pParams->pThreadData = pThreadData;

        hNewThread = CreateThread(NULL, 0, OSThreadLauncher, pParams, 0, NULL);

        if (hNewThread == NULL)
        {
            NT_LOG_ERROR("ERROR: Failed to create thread!!.");

            FreeAligned(pParams);
            result = CDKResultEFailed;
        }
        else
        {
            *phThread = hNewThread;
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::ThreadSetName
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult OsUtils::ThreadSetName(
    OSThreadHandle  hThread,
    const CHAR*     pName)
{
    NATIVETEST_UNUSED_PARAM(hThread);
    NATIVETEST_UNUSED_PARAM(pName);

    /// @todo (CAMX-32) - Pending Windows implementation
    NT_LOG_ERROR("OsUtils::ThreadSetName NOT IMPLEMENTED");

    return CDKResultEFailed;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::ThreadWait
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID OsUtils::ThreadWait(
    OSThreadHandle hThread)
{
    WaitForSingleObject(hThread, INFINITE);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::SleepMicroseconds
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID OsUtils::SleepMicroseconds(
    UINT microseconds)
{
    // Sleep takes millisecond param
    ::Sleep(/*convert to milliseconds*/(microseconds / 1000));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::LibGetAddr
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID* OsUtils::LibGetAddr(
    OSLIBRARYHANDLE hLibrary,
    const CHAR*     pProcName)
{
    FARPROC pProcAddr = NULL;

    if (hLibrary != NULL)
    {
        pProcAddr = GetProcAddress(static_cast<HMODULE>(hLibrary), pProcName);
    }

    return pProcAddr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::GetThreadID
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT OsUtils::GetThreadID()
{
    return GetCurrentThreadId();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::GetProcessID
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT OsUtils::GetProcessID()
{
    return static_cast<UINT>(GetCurrentProcessId());
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// String Functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::VSNPrintF
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT OsUtils::VSNPrintF(
    CHAR*       pDst,
    SIZE_T      sizeDst,
    const CHAR* pFormat,
    va_list     argptr)
{
    INT numCharWritten = 0;
    numCharWritten = vsnprintf_s(pDst, sizeDst, _TRUNCATE, pFormat, argptr);
    if (numCharWritten < 0)
    {
        NT_LOG_ERROR("VSNPrintF: failed to write characters!");
    }
    if ((numCharWritten >= static_cast<INT>(sizeDst)) && (sizeDst > 0))
    {
        // Message length exceeds the buffer limit size
        NT_LOG_ERROR("Message length: %d exceeds the buffer limit size: %u", numCharWritten, sizeDst);
        numCharWritten = -1;
    }
    return numCharWritten;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::StrNCmp
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT OsUtils::StrNCmp(
    const CHAR* pString1,
    const CHAR* pString2,
    SIZE_T      maxCount)
{
    return strncmp(pString1, pString2, maxCount);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::StrNICmp
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT OsUtils::StrNICmp(
    const CHAR* pString1,
    const CHAR* pString2,
    SIZE_T      maxCount)
{
    return _strnicmp(pString1, pString2, maxCount);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::StrLCat
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SIZE_T OsUtils::StrLCat(
    CHAR*       pDst,
    const CHAR* pSrc,
    SIZE_T      sizeDst)
{
    SIZE_T lengthSrc = StrLen(pSrc);
    SIZE_T lengthDst = StrLen(pDst);

    strncat_s(pDst, sizeDst, pSrc, _TRUNCATE);

    return lengthSrc + lengthDst;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::StrLCpy
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SIZE_T OsUtils::StrLCpy(
    CHAR*       pDst,
    const CHAR* pSrc,
    SIZE_T      length)
{
    SIZE_T lengthSrc = 0;

    if (length > 0)
    {
        lengthSrc = StrLen(pSrc);
        strncpy_s(pDst, length, pSrc, _TRUNCATE);
    }

    return lengthSrc;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::StrTokReentrant
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHAR* OsUtils::StrTokReentrant(
    CHAR*       pSrc,
    const CHAR* pDelimiter,
    CHAR**      ppContext)
{
    return strtok_s(pSrc, pDelimiter, ppContext);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// OsUtils::GetTime
///
/// @brief  Gets the current time
///
/// @param  pTime Output time structure
///
/// @return None
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID OsUtils::GetTime(
    CDKTime* pTime)
{
    if (NULL == pTime)
    {
        NT_LOG_ERROR("pTime is NULL!");
        return;
    }

    LARGE_INTEGER tickFrequency;
    QueryPerformanceFrequency(&tickFrequency);

    LARGE_INTEGER timeInTicks;
    QueryPerformanceCounter(&timeInTicks);

    // Convert to nanoseconds
    LARGE_INTEGER timeInNano;
    timeInNano.QuadPart = timeInTicks.QuadPart * (1000000000);
    timeInNano.QuadPart /= tickFrequency.QuadPart;

    // Convert to seconds + nanoSeconds
    pTime->seconds = static_cast<UINT32>(timeInNano.QuadPart / (1000000000));
    pTime->nanoSeconds = static_cast<UINT32>(timeInNano.QuadPart % (1000000000));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// OsUtils::GetDateTime
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID OsUtils::GetDateTime(
    CDKDateTime* pDateTime)
{
    if (NULL == pDateTime)
    {
        NT_LOG_ERROR("pDateTime is NULL!");
        return;
    }
    SYSTEMTIME st;
    GetLocalTime(&st);
    pDateTime->seconds = static_cast<UINT32>(st.wSecond);
    pDateTime->milliseconds = static_cast<UINT32>(st.wMilliseconds);
    pDateTime->minutes = static_cast<UINT32>(st.wMinute);
    pDateTime->hours = static_cast<UINT32>(st.wHour);
    pDateTime->dayOfMonth = static_cast<UINT32>(st.wDay);
    pDateTime->month = static_cast<UINT32>(st.wMonth);
    pDateTime->year = static_cast<UINT32>(st.wYear);
    pDateTime->weekday = static_cast<UINT32>(st.wDayOfWeek);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// OsUtils::GetGMTime
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT OsUtils::GetGMTime(
    const time_t*   pTime,
    struct tm*      pResult)
{
    if (NULL == pTime)
    {
        NT_LOG_ERROR("pTime is NULL!");
        return -1;
    }
    if (NULL == pResult)
    {
        NT_LOG_ERROR("pResult is NULL!");
        return -1;
    }

    return gmtime_s(pResult, pTime);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OsUtils::Close
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult OsUtils::Close(
    INT FD)
{
    CDKResult result = CDKResultSuccess;
    if (-1 != FD)
    {
        if (0 != _close(FD))
        {
            result = CDKResultEFailed;
        }
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mutex class
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mutex::Create
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Mutex* Mutex::Create(
    const CHAR* pResourceName)
{
    Mutex* pMutex = NULL;

    pMutex = SAFE_NEW() Mutex();

    if (NULL != pMutex)
    {
        if (CDKResultSuccess != pMutex->Initialize(pResourceName))
        {
            delete pMutex;
            pMutex = NULL;
        }
    }

    return pMutex;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mutex::Initialize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult Mutex::Initialize(
    const CHAR* pResourceName)
{
    CDKResult result = CDKResultSuccess;

    InitializeCriticalSection(&m_criticalSection);

    if (pResourceName == NULL)
    {
        NT_LOG_ERROR("pResourceName is NULL!");
    }

    m_pResourceName = pResourceName;

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mutex::Destroy
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Mutex::Destroy()
{
    DeleteCriticalSection(&m_criticalSection);
    delete this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mutex::Lock
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Mutex::Lock()
{
    EnterCriticalSection(&m_criticalSection);
}
;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mutex::TryLock
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult Mutex::TryLock()
{
    CDKResult result = CDKResultSuccess;

    if (FALSE == TryEnterCriticalSection(&m_criticalSection))
    {
        result = CDKResultEBusy;
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mutex::Unlock
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Mutex::Unlock()
{
    LeaveCriticalSection(&m_criticalSection);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mutex::GetNativeHandle
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
OSMutexHandle* Mutex::GetNativeHandle()
{
    return &m_criticalSection;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Semaphore class
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Semaphore::Create
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Semaphore* Semaphore::Create()
{
    Semaphore* pSemaphore = NULL;

    pSemaphore = SAFE_NEW() Semaphore();

    if (NULL != pSemaphore)
    {
        if (CDKResultSuccess != pSemaphore->Initialize())
        {
            delete pSemaphore;
            pSemaphore = NULL;
        }
    }

    return pSemaphore;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Semaphore::Initialize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult Semaphore::Initialize()
{
    CDKResult result = CDKResultSuccess;

    m_hSemaphore = CreateSemaphore(NULL,    // default security attributes
        0,       // initial count
        1,       // maximum count
        NULL);   // unnamed semaphore

    if (NULL == m_hSemaphore)
    {
        result = CDKResultEFailed;
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Semaphore::Destroy
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Semaphore::Destroy()
{
    if (NULL != m_hSemaphore)
    {
        CloseHandle(m_hSemaphore);
        m_hSemaphore = NULL;
    }

    delete this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Semaphore::Wait
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Semaphore::Wait()
{
    DWORD waitResult;

    waitResult = WaitForSingleObject(m_hSemaphore, INFINITE);

    if (WAIT_OBJECT_0 != waitResult)
    {
        NT_LOG_ERROR("WAIT_OBJECT_0 != waitResult!");
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Semaphore::Signal
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Semaphore::Signal()
{
    ReleaseSemaphore(m_hSemaphore, 1, NULL); // 1    --> Increase semaphore count by 1
                                             // NULL --> Not interested in previous count
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Semaphore::TimedWait
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult Semaphore::TimedWait(
    UINT timeoutMilliseconds)
{
    CDKResult result = CDKResultSuccess;
    DWORD      waitResult = 0;

    waitResult = WaitForSingleObject(m_hSemaphore, timeoutMilliseconds);

    if (WAIT_OBJECT_0 != waitResult)
    {
        result = CDKResultEFailed;
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Condition class
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Condition::Create
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Condition* Condition::Create(
    const CHAR* pResource)
{
    Condition* pCondition = NULL;

    pCondition = SAFE_NEW() Condition();

    if (NULL != pCondition)
    {
        if (CDKResultSuccess != pCondition->Initialize(pResource))
        {
            delete pCondition;
            pCondition = NULL;
        }
    }

    return pCondition;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Condition::Destroy
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Condition::Destroy()
{
    WakeAllConditionVariable(&m_conditionVar);
    delete this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Condition::Initialize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult Condition::Initialize(
    const CHAR* pResource)
{
    InitializeConditionVariable(&m_conditionVar);
    m_pResource = pResource;

    return CDKResultSuccess;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Condition::Wait
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult Condition::Wait(
    OSMutexHandle* phMutex)
{
    SleepConditionVariableCS(&m_conditionVar, phMutex, INFINITE);

    return CDKResultSuccess;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Condition::TimedWait
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDKResult Condition::TimedWait(
    OSMutexHandle*  phMutex,
    UINT            timeoutMilliseconds)
{
    CDKResult result = CDKResultSuccess;
    BOOL       waitResult = FALSE;

    waitResult = SleepConditionVariableCS(&m_conditionVar, phMutex, timeoutMilliseconds);

    if (FALSE == waitResult)
    {
        result = CDKResultEFailed;
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Condition::Signal
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Condition::Signal()
{
    WakeConditionVariable(&m_conditionVar);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Condition::Broadcast
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID Condition::Broadcast()
{
    WakeAllConditionVariable(&m_conditionVar);
}

} // namespace tests

#endif // defined (_WIN32)